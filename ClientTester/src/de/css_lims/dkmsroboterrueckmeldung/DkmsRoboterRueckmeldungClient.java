package de.css_lims.dkmsroboterrueckmeldung;

import static de.css_lims.dkmsroboterrueckmeldung.RueckmeldungRequest.DynamischerTeil;
import static de.css_lims.dkmsroboterrueckmeldung.RueckmeldungRequest.DynamischerTeil.DynamischerTyp;
import static de.css_lims.dkmsroboterrueckmeldung.RueckmeldungRequest.DynamischerTeil.DynamischerTyp.DynamischesObjekt;
import static de.css_lims.dkmsroboterrueckmeldung.RueckmeldungRequest.DynamischerTeil.DynamischerTyp.DynamischesObjekt.WertObjekt;
import de.css_lims.dkmsroboterrueckmeldung.types.MaterialKeys;
import de.css_lims.dkmsroboterrueckmeldung.types.TargetKeys;

import java.math.BigInteger;

import java.util.EnumMap;
import java.util.GregorianCalendar;
import java.util.Iterator;
import java.util.List;
import java.util.UUID;

import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;

// This source file is generated by Oracle tools.
// Contents may be subject to change.
// For reporting problems, use the following:
// Generated by Oracle JDeveloper 12c Development Build 12.2.1.1.0.2047
public class DkmsRoboterRueckmeldungClient {

    public static void main(String[] args) throws CloneNotSupportedException {
        DkmsRoboterRueckmeldung_Service dkmsRoboterRueckmeldung_Service = new DkmsRoboterRueckmeldung_Service();
        DkmsRoboterRueckmeldung dkmsRoboterRueckmeldung = dkmsRoboterRueckmeldung_Service.getDkmsRoboterRueckmeldung();
        /*
       * Build the Request
       */
        RueckmeldungRequest rueckmeldungRequest = initializeRequest(0);

        /*
         * dTeil has a List of dTyps, so get and fill it
         */
        List<DynamischerTyp> dTypList =  rueckmeldungRequest.getDynamischerTeil().getDynamischerTyp();

        /*
         * create ALL DynamischerTyp "materials" and "targets" and add to
         * dTypList
         */

        DynamischerTyp dTyp = new DynamischerTyp();
        dTyp.setName("MATERIALS");
        dTypList.add(dTyp);

        dTyp = new DynamischerTyp();
        dTyp.setName("SOURCE_POS");
        dTypList.add(dTyp);

        dTyp = new DynamischerTyp();
        dTyp.setName("TARGET_POS");
        dTypList.add(dTyp);

        /*
         * dTyp materials has a materialsdObjektList
         */
        
        
        List<DynamischesObjekt> materialIdObjektList = dTypList.get(0).getDynamischesObjekt();
        /*
        * create the DynamischesObjekt
        */
        DynamischesObjekt dObjekt = new DynamischesObjekt();
        /*
         * and set the position
         */
        dObjekt.setPosition(new BigInteger("1"));
        materialIdObjektList.add(dObjekt);
        /*
         * and get and fill the  List<WertObjekt> wObjektList
         */
        List<WertObjekt> wObjektList = dObjekt.getWertObjekt();

        EnumMap<MaterialKeys, String> sourceMap = new EnumMap<>(MaterialKeys.class);
        sourceMap.put(MaterialKeys.ID, "Mat-Id");
        sourceMap.put(MaterialKeys.TYPE, "MATERIAL");
        sourceMap.put(MaterialKeys.NAME, "HLA-A");
        sourceMap.put(MaterialKeys.CONTAINER, "384");

        createObjektList(wObjektList, sourceMap);

        /*
        * create another DynamischesObjekt
        */
        dObjekt = new DynamischesObjekt();
        /*
         * and set the position
         */
        dObjekt.setPosition(new BigInteger("2"));
        dTypList.get(0)
                .getDynamischesObjekt()
                .add(dObjekt);
        wObjektList = dObjekt.getWertObjekt();
        sourceMap = new EnumMap<>(MaterialKeys.class);
        sourceMap.put(MaterialKeys.ID, "Mat-Id");
        sourceMap.put(MaterialKeys.TYPE, "MATERIAL");
        sourceMap.put(MaterialKeys.NAME, "HLA-B");
        sourceMap.put(MaterialKeys.CONTAINER, "384");
        createObjektList(wObjektList, sourceMap);


        /*
        * create another DynamischesObjekt
        */
        dObjekt = new DynamischesObjekt();
        /*
         * and set the position
         */
//        dObjekt.setPosition(new BigInteger("1"));
//        dTypList.get(0)
//                .getDynamischesObjekt()
//                .add(dObjekt);
//        wObjektList = dObjekt.getWertObjekt();
//        sourceMap = new EnumMap<>(SourceKeys.class);
//        sourceMap.put(SourceKeys.CHARGE, "LOT-No");
//        sourceMap.put(SourceKeys.ID, "Mat-Id");
//        sourceMap.put(SourceKeys.TYPE, "MATERIAL");
//        sourceMap.put(SourceKeys.NAME, "Polymerase");
//        sourceMap.put(SourceKeys.CONTAINER, "tube");
//        createObjektList(wObjektList, sourceMap);


        
//        dObjekt = newInstance(dObjekt);
//        dObjekt.setPosition(new BigInteger("2"));
//        dTypList.get(0)
//                .getDynamischesObjekt()
//                .add(dObjekt);

        dObjekt = new DynamischesObjekt();
        dObjekt.setPosition(new BigInteger("1"));
        dTypList.get(1)
                .getDynamischesObjekt()
                .add(dObjekt);
        wObjektList = dObjekt.getWertObjekt();
        EnumMap<TargetKeys, String> targetMap = new EnumMap<>(TargetKeys.class);
        targetMap = new EnumMap<>(TargetKeys.class);
        targetMap.put(TargetKeys.CHARGE, "LOT-No");
        targetMap.put(TargetKeys.ID, "PlateId");
        targetMap.put(TargetKeys.TYPE, "targetPlate");
        targetMap.put(TargetKeys.NAME, "HLA-A");
        targetMap.put(TargetKeys.CONTAINER, "384");
        createObjektList(wObjektList, targetMap);


//        dObjekt = new DynamischesObjekt();
//        dObjekt.setPosition(new BigInteger("2"));
//        dTypList.get(1)
//                .getDynamischesObjekt()
//                .add(dObjekt);
//        wObjektList = dObjekt.getWertObjekt();
//        targetMap = new EnumMap<>(TargetKeys.class);
//        targetMap.put(TargetKeys.CHARGE, "LOT-No");
//        targetMap.put(TargetKeys.ID, "PlateId");
//        targetMap.put(TargetKeys.TYPE, "targetPlate");
//        targetMap.put(TargetKeys.NAME, "HLA-B");
//        targetMap.put(TargetKeys.CONTAINER, "384");
//        createObjektList(wObjektList, targetMap);

        RueckmeldeungResponse rueckmeldeungResponse =
            dkmsRoboterRueckmeldung.dkmsRoboterRueckmeldung(rueckmeldungRequest);
        System.out.println(rueckmeldeungResponse.getStatus());

    } // end main

    /**
     * Alternative style for a copy constructor, using a static newInstance
     * method.
     */
    public static DynamischesObjekt newInstance(DynamischesObjekt dObjekt) {
        DynamischesObjekt dObjektCopy = new DynamischesObjekt();
        dObjektCopy.wertObjekt = dObjekt.getWertObjekt();
        return dObjektCopy;
    }


//    private static void createMaterialsObjektList(List<WertObjekt> wObjektList, EnumMap<SourceKeys, String> werteMap) {
//        Iterator<SourceKeys> enumKeySet = werteMap.keySet().iterator();
//        while (enumKeySet.hasNext()) {
//            SourceKeys key = enumKeySet.next();
//            WertObjekt wObjekt = new WertObjekt();
//            wObjekt.setName(key.name());
//            wObjekt.setInhalt(werteMap.get(key));
//            wObjektList.add(wObjekt);
//        }
//    }
//
//    private static void createTargetObjektList(List<WertObjekt> wObjektList, EnumMap<TargetKeys, String> werteMap) {
//        Iterator<TargetKeys> enumKeySet = werteMap.keySet().iterator();
//        while (enumKeySet.hasNext()) {
//            TargetKeys key = enumKeySet.next();
//            WertObjekt wObjekt = new WertObjekt();
//            wObjekt.setName(key.name());
//            wObjekt.setInhalt(werteMap.get(key));
//            wObjektList.add(wObjekt);
//        }
//    }

    private static void createObjektList(List<WertObjekt> wObjektList, EnumMap<? extends Enum, String> werteMap) {
        // for (Object o :  )
        Iterator<?> enumKeySet = werteMap.keySet().iterator();
        while (enumKeySet.hasNext()) {

            Object key = enumKeySet.next();
            // System.out.println(key.getClass());
            if (key instanceof MaterialKeys) {
                MaterialKeys temp = (MaterialKeys) key;
                WertObjekt wObjekt = new WertObjekt();
                wObjekt.setName(temp.name());
                wObjekt.setInhalt(werteMap.get(temp));
                wObjektList.add(wObjekt);
            }
            if (key instanceof TargetKeys) {
                TargetKeys temp = (TargetKeys) key;
                WertObjekt wObjekt = new WertObjekt();
                wObjekt.setName(temp.name());
                wObjekt.setInhalt(werteMap.get(temp));
                wObjektList.add(wObjekt);

            }
        }

    }

    private static void createDynamischesObject(DynamischerTeil dTeil, DynamischerTyp dTyp, int  position ) {
        
    }
    
    private static RueckmeldungRequest initializeRequest(int typ) {
        RueckmeldungRequest rueckmeldungRequest = new RueckmeldungRequest();

        /*
         * Build the static content of the Request
         */
        GregorianCalendar gcal = new GregorianCalendar();
        XMLGregorianCalendar xgcal = null;
        try {
            xgcal = DatatypeFactory.newInstance().newXMLGregorianCalendar(gcal);
        } catch (DatatypeConfigurationException e) {
            System.err.println(e.getStackTrace());
        }
        rueckmeldungRequest.setZeitstempel(xgcal);
        rueckmeldungRequest.setRackId("AL1234562");
        rueckmeldungRequest.setRoboterId("MSM1");
        rueckmeldungRequest.setUserBedienerId("P006");
        rueckmeldungRequest.setProgrammId("001");
        rueckmeldungRequest.setHinweisText("MSM1 ist defekt");
        /*
         * optional userKontrolleurId
         */
        rueckmeldungRequest.setUserKontrolleurId("userKontrolleurIdString");
        


        /*
         * realize a unique requestId from diverse robots
         */
        String uniqueID = UUID.randomUUID().toString();
        rueckmeldungRequest.setRequestId(uniqueID);

        /*
         *  Questions:
         *  What can be transported by using requestTyp ?
         *  0 = Test & Validate
         *  1 = Track
         */
        
        rueckmeldungRequest.setRequestTyp(new BigInteger(String.valueOf(typ)));
        /*
         * set dynamischen Teil - there is only ONE in each XML request.
         */
        DynamischerTeil dTeil = new DynamischerTeil();
        rueckmeldungRequest.setDynamischerTeil(dTeil);
        
        return rueckmeldungRequest;
    }

} //end class
